import functools
import json
import logging
import subprocess
from typing import Union

import peewee

from .core import BaseModel, get_targets_predicate, plugin
from .nmap import HostModel, ServiceModel


class ExploitModel(BaseModel):
    EXPLOIT_TYPE_DOS = "dos"
    EXPLOIT_TYPE_LOCAL = "local"
    EXPLOIT_TYPE_REMOTE = "remote"
    EXPLOIT_TYPE_CHOICES = (
        (EXPLOIT_TYPE_DOS, "dos"),
        (EXPLOIT_TYPE_LOCAL, "local"),
        (EXPLOIT_TYPE_REMOTE, "remote"),
    )

    is_table = True

    service = peewee.ForeignKeyField(ServiceModel, backref="vulnerabilities")
    edb_id = peewee.IntegerField(index=True)

    title = peewee.CharField()
    exploit_type = peewee.CharField(choices=EXPLOIT_TYPE_CHOICES)

    class Meta:
        db_table = "exploit"
        indexes = ((("service", "edb_id"), True),)

    def get_url(self) -> str:
        return f"https://www.exploit-db.com/exploits/{self.edb_id}"


@plugin("exploit_search")
def exploit_researcher(*targets: Union[str, int], logger: logging.Logger, **_):
    @functools.cache
    def run_searchsploit(*_keywords: str) -> dict[str, ...]:
        """
        A cached function to run searchsploit on keywords.
        New keywords are run then result is stored in cache

        :param _keywords: keywords to use with searchsploit
        :return: searchsploit dict results
        """
        cmd = ["searchsploit", "--json", "remote", *_keywords]

        logger.debug(f"Running command: {' '.join(cmd)}")

        return json.loads(
            subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode()
        )

    targets_predicate = get_targets_predicate(*targets)

    services_query = (
        ServiceModel.select(ServiceModel, HostModel.operating_system)
        .join_from(ServiceModel, HostModel, on=(ServiceModel.host == HostModel.id))
        .where((ServiceModel.product.is_null(False)) & targets_predicate)
    ).objects()

    exploit_to_create = []
    for service in services_query:
        logger.debug(f"Checking service {service.protocol}/{service.port}")

        keywords = set()

        if service.product is not None:
            keywords = keywords.union(service.product.lower().split(" "))

        if service.operating_system is not None:
            keywords.add(service.operating_system.lower())

        if service.version is not None:
            if service.name == "ssh":
                # SSH versions include OS information
                # Too specific for searchsploit
                keywords.add(service.version.split(" ", 1)[0])
            else:
                keywords.add(service.version)

        # no keyword found (should not occur)
        if len(keywords) == 0:
            logger.warning(
                f"No keyword found for service {service.protocol}/{service.port}"
            )
            continue

        proc_result = run_searchsploit(*keywords)

        for exploit_data in proc_result["RESULTS_EXPLOIT"]:
            exploit_edb = exploit_data["EDB-ID"]
            exploit_exists = (
                ExploitModel.select()
                .where(
                    (ExploitModel.service == service.get_id())
                    & (ExploitModel.edb_id == exploit_edb)
                )
                .exists()
            )

            if not exploit_exists:
                exploit = ExploitModel(
                    service=service,
                    edb_id=exploit_edb,
                    title=exploit_data["Title"],
                    exploit_type=exploit_data["Type"],
                )
                exploit_to_create.append(exploit)

    logger.info(f"Found {len(exploit_to_create)} new exploits.")

    if len(exploit_to_create) > 0:
        ExploitModel.bulk_create(exploit_to_create)
